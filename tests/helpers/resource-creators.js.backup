// @ts-check
/**
 * üîß RESOURCE CREATORS - MODO REAL
 *
 * Fun√ß√µes helper para CRIAR recursos reais quando n√£o existem
 * Usado pelos testes para eliminar test.skip()
 *
 * IMPORTANTE: Estas fun√ß√µes custam dinheiro (VAST.ai cr√©ditos)
 */

/**
 * Garantir que existe pelo menos uma m√°quina GPU
 * Se n√£o existir, CRIA UMA usando VAST.ai real
 */
async function ensureGpuMachineExists(page) {
  await page.goto('/app/machines');
  await page.waitForLoadState('domcontentloaded'); // Mais confi√°vel que networkidle
  await page.waitForTimeout(2000);

  // Verificar se j√° existe alguma m√°quina (usando getByText - AI-friendly)
  const hasMachine = await page.getByText(/RTX|A100|H100/).isVisible().catch(() => false);
  if (hasMachine) {
    console.log('‚úÖ J√° existe m√°quina GPU');
    return;
  }

  console.log('‚ö†Ô∏è Nenhuma m√°quina encontrada - CRIANDO UMA...');

  // Navegar para criar m√°quina
  await page.goto('/app');
  await page.waitForLoadState('domcontentloaded');

  // Fechar modal de boas-vindas
  const skipButton = page.getByText('Pular tudo');
  if (await skipButton.isVisible({ timeout: 2000 }).catch(() => false)) {
    await skipButton.click();
    await page.waitForTimeout(500);
  }

  // Clicar em "Buscar M√°quinas" usando getByRole (robusto!)
  const searchButton = page.getByRole('button', { name: /Buscar.*M√°quinas/i });
  if (await searchButton.isVisible({ timeout: 5000 }).catch(() => false)) {
    await searchButton.click();
    console.log('üîÑ Aguardando ofertas VAST.ai...');
    await page.waitForTimeout(5000); // Aguardar API VAST.ai

    // Aguardar ofertas carregarem
    await page.waitForSelector('text=/RTX|A100|GPU/', { timeout: 15000 }).catch(() => {
      console.log('‚ö†Ô∏è Nenhuma oferta encontrada');
    });

    // Selecionar primeira oferta dispon√≠vel
    const selectButtons = page.getByRole('button', { name: /Selecionar|Select/i });
    const selectCount = await selectButtons.count();

    if (selectCount > 0) {
      await selectButtons.first().click();
      console.log(`‚úÖ Oferta selecionada (${selectCount} dispon√≠veis)`);
      await page.waitForTimeout(1000);

      // Confirmar cria√ß√£o
      const createButton = page.getByRole('button', { name: /Criar|Create/i }).last();
      await createButton.click();

      console.log('üîÑ Aguardando VAST.ai provisionar m√°quina... (1-5 min)');

      // Aguardar provisionamento (pode demorar)
      for (let i = 0; i < 60; i++) { // 10 minutos m√°ximo
        await page.waitForTimeout(10000); // 10s
        await page.goto('/app/machines');
        await page.waitForLoadState('domcontentloaded');

        if (await page.getByText(/RTX|A100|H100/).isVisible().catch(() => false)) {
          console.log(`‚úÖ M√°quina criada ap√≥s ${(i + 1) * 10}s`);
          return;
        }

        if (i % 6 === 0) {
          console.log(`‚è≥ Aguardando provisionamento... ${(i + 1) * 10}s`);
        }
      }

      throw new Error('Timeout: m√°quina n√£o foi provisionada em 10 minutos');
    }
  }

  throw new Error('N√£o foi poss√≠vel criar m√°quina - bot√£o de buscar n√£o encontrado');
}

/**
 * Garantir que existe uma m√°quina ONLINE
 */
async function ensureOnlineMachine(page) {
  await page.goto('/app/machines');
  await page.waitForLoadState('domcontentloaded');
  await page.waitForTimeout(1000);

  // Verificar se j√° existe m√°quina online
  const hasOnline = await page.getByText('Online').isVisible().catch(() => false);
  if (hasOnline) {
    console.log('‚úÖ J√° existe m√°quina online');
    return;
  }

  console.log('‚ö†Ô∏è Nenhuma m√°quina online - verificando se tem offline...');

  // Verificar se tem m√°quina offline para iniciar
  const hasOffline = await page.getByText('Offline').isVisible().catch(() => false);
  if (hasOffline) {
    console.log('üîÑ Iniciando m√°quina offline...');

    const startButton = page.locator('button:has-text("Iniciar")').first();
    if (await startButton.isVisible().catch(() => false)) {
      await startButton.click();
      await page.waitForTimeout(5000); // Aguardar iniciar

      console.log('‚úÖ M√°quina iniciada');
      return;
    }
  }

  // Se n√£o tem nenhuma m√°quina, criar uma
  console.log('‚ö†Ô∏è Criando nova m√°quina GPU...');
  await ensureGpuMachineExists(page);

  // Garantir que a nova m√°quina est√° online
  await page.goto('/app/machines');
  await page.waitForLoadState('networkidle');
  const isOnline = await page.locator('text="Online"').isVisible().catch(() => false);

  if (!isOnline) {
    console.log('üîÑ Nova m√°quina est√° offline - iniciando...');
    const startButton = page.locator('button:has-text("Iniciar")').first();
    if (await startButton.isVisible().catch(() => false)) {
      await startButton.click();
      await page.waitForTimeout(5000);
    }
  }

  console.log('‚úÖ M√°quina online dispon√≠vel');
}

/**
 * Garantir que existe uma m√°quina OFFLINE
 */
async function ensureOfflineMachine(page) {
  await page.goto('/app/machines');
  await page.waitForLoadState('networkidle');
  await page.waitForTimeout(1000);

  // Verificar se j√° existe m√°quina offline
  const hasOffline = await page.locator('text="Offline"').isVisible().catch(() => false);
  if (hasOffline) {
    console.log('‚úÖ J√° existe m√°quina offline');
    return;
  }

  console.log('‚ö†Ô∏è Nenhuma m√°quina offline - pausando uma online...');

  // Pausar uma m√°quina online
  const pauseButton = page.locator('button:has-text("Pausar")').first();
  if (await pauseButton.isVisible().catch(() => false)) {
    await pauseButton.click();

    // Confirmar no modal
    const confirmButton = page.locator('button:has-text("Pausar")').last();
    if (await confirmButton.isVisible({ timeout: 3000 }).catch(() => false)) {
      await confirmButton.click();
      await page.waitForTimeout(3000);
    }

    console.log('‚úÖ M√°quina pausada');
    return;
  }

  // Se n√£o tem m√°quina online, criar uma e pausar
  console.log('‚ö†Ô∏è Criando m√°quina para pausar...');
  await ensureGpuMachineExists(page);
  await ensureOfflineMachine(page); // Recursivo
}

/**
 * Garantir que existe uma m√°quina com CPU Standby
 */
async function ensureMachineWithCpuStandby(page) {
  await page.goto('/app/machines');
  await page.waitForLoadState('networkidle');
  await page.waitForTimeout(1000);

  // Verificar se j√° existe m√°quina com backup
  const hasBackup = await page.locator('button:has-text("Backup")').isVisible().catch(() => false);
  if (hasBackup) {
    console.log('‚úÖ J√° existe m√°quina com CPU Standby');
    return;
  }

  console.log('‚ö†Ô∏è Nenhuma m√°quina com CPU Standby - habilitando...');

  // Primeiro garantir que existe uma m√°quina
  await ensureGpuMachineExists(page);

  // Ir para Settings e habilitar CPU Standby
  await page.goto('/app/settings');
  await page.waitForLoadState('networkidle');
  await page.waitForTimeout(1000);

  // Procurar por configura√ß√£o de CPU Failover/Standby
  const enableStandbyToggle = page.locator('input[type="checkbox"]').filter({
    has: page.locator('text=/CPU|Standby|Failover|Backup/')
  }).first();

  if (await enableStandbyToggle.isVisible().catch(() => false)) {
    const isChecked = await enableStandbyToggle.isChecked();
    if (!isChecked) {
      await enableStandbyToggle.click();
      await page.waitForTimeout(2000); // Aguardar GCP provisionar

      // Salvar configura√ß√µes
      const saveButton = page.locator('button:has-text(/Salvar|Save/)').first();
      if (await saveButton.isVisible().catch(() => false)) {
        await saveButton.click();
        await page.waitForTimeout(3000);
      }

      console.log('‚úÖ CPU Standby habilitado via Settings');
      return;
    }
  }

  // Alternativa: habilitar direto na p√°gina de m√°quinas
  await page.goto('/app/machines');
  await page.waitForLoadState('networkidle');

  const enableButton = page.locator('button:has-text(/Ativar Backup|Enable Standby/)').first();
  if (await enableButton.isVisible().catch(() => false)) {
    await enableButton.click();
    await page.waitForTimeout(5000); // Aguardar GCP provisionar

    console.log('‚úÖ CPU Standby habilitado');
    return;
  }

  console.log('‚ö†Ô∏è N√£o foi poss√≠vel habilitar CPU Standby automaticamente');
  console.log('‚ÑπÔ∏è Feature pode n√£o estar dispon√≠vel ou requer configura√ß√£o manual');
}

/**
 * Garantir que existe uma m√°quina com IP vis√≠vel
 */
async function ensureMachineWithIP(page) {
  await page.goto('/app/machines');
  await page.waitForLoadState('networkidle');
  await page.waitForTimeout(1000);

  // Verificar se j√° existe m√°quina com IP
  const hasIP = await page.locator('text=/\\d+\\.\\d+\\.\\d+\\.\\d+/').isVisible().catch(() => false);
  if (hasIP) {
    console.log('‚úÖ J√° existe m√°quina com IP vis√≠vel');
    return;
  }

  console.log('‚ö†Ô∏è Nenhuma m√°quina com IP - iniciando uma...');

  // M√°quinas s√≥ mostram IP quando est√£o online
  await ensureOnlineMachine(page);

  // Verificar novamente
  await page.goto('/app/machines');
  await page.waitForLoadState('networkidle');
  const hasIPNow = await page.locator('text=/\\d+\\.\\d+\\.\\d+\\.\\d+/').isVisible().catch(() => false);

  if (hasIPNow) {
    console.log('‚úÖ M√°quina com IP dispon√≠vel');
  } else {
    console.log('‚ö†Ô∏è M√°quina online mas IP n√£o vis√≠vel (pode demorar alguns segundos)');
    await page.waitForTimeout(5000);
  }
}

/**
 * Destruir TODAS as m√°quinas (cleanup ap√≥s testes)
 */
async function destroyAllMachines(page) {
  await page.goto('/app/machines');
  await page.waitForLoadState('networkidle');
  await page.waitForTimeout(1000);

  console.log('üßπ CLEANUP: Destruindo todas as m√°quinas...');

  let iterationCount = 0;
  const maxIterations = 20; // Prote√ß√£o contra loop infinito

  while (iterationCount < maxIterations) {
    // Procurar por bot√£o "Destruir"
    const destroyButton = page.locator('button:has-text("Destruir")').first();
    const hasDestroy = await destroyButton.isVisible({ timeout: 2000 }).catch(() => false);

    if (!hasDestroy) {
      console.log('‚úÖ Todas as m√°quinas destru√≠das');
      break;
    }

    await destroyButton.click();

    // Confirmar no modal
    const confirmButton = page.locator('button:has-text(/Confirmar|Destruir/)').last();
    if (await confirmButton.isVisible({ timeout: 3000 }).catch(() => false)) {
      await confirmButton.click();
      await page.waitForTimeout(2000);
      console.log(`‚úÖ M√°quina ${iterationCount + 1} destru√≠da`);
    }

    // Recarregar p√°gina para ver atualiza√ß√£o
    await page.goto('/app/machines');
    await page.waitForLoadState('networkidle');

    iterationCount++;
  }

  if (iterationCount >= maxIterations) {
    console.log('‚ö†Ô∏è Atingiu limite de itera√ß√µes no cleanup');
  }
}

module.exports = {
  ensureGpuMachineExists,
  ensureOnlineMachine,
  ensureOfflineMachine,
  ensureMachineWithCpuStandby,
  ensureMachineWithIP,
  destroyAllMachines,
};
